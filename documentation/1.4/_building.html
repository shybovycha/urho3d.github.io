---
layout: documentation
group: 1.4
---
<div id="top">{% comment %}<!-- do not remove this div, it is closed by doxygen! -->{% endcomment %}
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Building Urho3D </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h4>Table of Contents</h4>
<ul><li class="level1"><a href="#Building_Prerequisites">Building prerequisites</a></li>
<li class="level1"><a href="#Build_Scripts">Build scripts</a></li>
<li class="level1"><a href="#Build_Options">Build options</a></li>
<li class="level1"><a href="#Building_Native">Native build process</a></li>
<li class="level1"><a href="#Building_Android">Android build process</a></li>
<li class="level1"><a href="#Building_Ios">iOS build process</a></li>
<li class="level1"><a href="#Building_RaspberryPi">Raspberry Pi build process</a></li>
<li class="level1"><a href="#Building_MinGW">MinGW cross-compile build process</a></li>
<li class="level1"><a href="#Building_Emscripten">Emscripten build process (EXPERIMENTAL)</a></li>
<li class="level1"><a href="#Building_64bit">Native 64bit build</a></li>
<li class="level1"><a href="#Building_Library">Library build</a></li>
<li class="level1"><a href="#Building_Docs">Documentation build</a></li>
<li class="level1"><a href="#Building_Shaders">Compiling Direct3D shaders</a></li>
<li class="level1"><a href="#Using_ccache">Using ccache</a></li>
</ul>
</div>
<div class="textblock"><h2><a class="anchor" id="Building_Prerequisites"></a>
Building prerequisites</h2>
<p>Although all required third-party libraries are included as source code, there are system-level dependencies that must be satisfied before Urho3D can be built successfully:</p>
<ul>
<li>For Windows, the June 2010 DirectX SDK needs to be installed. This is not necessary if building on Visual Studio 2012 or newer, which install the Windows SDK with the necessary DirectX files.</li>
</ul>
<ul>
<li>For Linux, the following development packages need to be installed: 
<ul>
<li><strong>Debian:</strong> <code>libx11-dev libxrandr-dev libasound2-dev libgl1-mesa-dev</code></li>
<li><strong>RedHat:</strong> <code>libX11-devel libXrandr-devel alsa-lib-devel mesa-libGL-devel</code></li>
</ul>
Packages <code>libgl1-mesa-dev</code> (Debian) or <code>mesa-libGL-devel</code> (RH) are needed when your GPU driver does not include OpenGL headers &amp; libs, but in most of the case it usually does and has better performance than Mesa's OpenGL implementation. Building as 32-bit on a 64-bit system requires installing also the 32-bit versions of the development libraries.
</li>
</ul>
<ul>
<li>For Raspberry Pi, the following development packages need to be installed. On Raspbian: libasound2-dev, libudev-dev. On Pidora: alsa-lib-devel, systemd-devel.</li>
</ul>
<ul>
<li>For Mac OS X, the Xcode developer tools package should include everything necessary. Make sure that the Xcode command line tools are also installed.</li>
</ul>
<ul>
<li>For Android, the Android SDK and Android NDK (minimum API level 12) need to be installed.</li>
</ul>
<ul>
<li>For Emscripten, the Emscripten SDK need to be installed (on Windows also MinGW toolchain is required.)</li>
</ul>
<p>To run Urho3D, the minimum system requirements are:</p>
<ul>
<li>Windows: CPU with SSE instructions support, Windows XP or newer, DirectX 9.0c, GPU with Shader Model 3 support.</li>
</ul>
<ul>
<li>Linux &amp; Mac OS X: CPU with SSE instructions support, GPU with OpenGL 2.0 support, EXT_framebuffer_object and EXT_packed_depth_stencil extensions.</li>
</ul>
<ul>
<li>Raspberry Pi: Model B revision 2.0 with at least 128 MB of 512 MB SDRAM allocated for GPU.</li>
</ul>
<ul>
<li>Android: OS version 2.3 or newer, OpenGL ES 2.0 capable GPU.</li>
</ul>
<ul>
<li>iOS: OpenGL ES 2.0 capable GPU.</li>
</ul>
<ul>
<li>Emscripten: modern browsers with fast JavaScript engine and HTML5 and WebGL support.</li>
</ul>
<p>SSE requirement can be eliminated by disabling the use of SSE instruction set, see URHO3D_SSE build option below.</p>
<p>CMake is required to configure and generate the Urho3D project build tree. The minimum required version is 2.8.6. However, it is recommended to use the latest CMake version avaiable out there, especially when targeting Mac OS X and iOS platforms using the latest Xcode version available. This is because Apple is known to change the internal working of Xcode with little regards to other third party build tools, such as CMake.</p>
<h2><a class="anchor" id="Build_Scripts"></a>
Build scripts</h2>
<p>As this is a cross-platform project, we have provided a number of build scripts for the most common use cases. The shell scripts end with extension *.sh are meant for building Urho3D project in a Unix-like host system (Linux, Mac, and even Raspberry Pi), while the batch files end with *.bat are meant for Windows host system only. They only provide a convenient way to invoke CMake to process our CMakeLists.txt files. Their usage is not a must as you can also invoke CMake to do the same via cmake-gui or via your IDE when your IDE supports that.</p>
<p>The basic usage is as follows:</p>
<pre class="fragment">&lt;script-name&gt; /path/to/build-tree [build-options]
</pre><p>Where the &lt;script-name&gt; is one of the provided build script. The /path/to/build-tree is where CMake will be generating the build tree for the project. Both out-of-source build tree and non out-of-source build tree path are now supported. The build options are described in detail in the <a class="el" href="_building.html#Build_Options">next section</a> below.</p>
<p>After the build tree has been generated, you can use the build script again to reconfigure it by passing different build options. You can do so as the basic usage above; or by first change the working directory to the already generated build tree and use the following syntax:</p>
<pre class="fragment">&lt;script-name&gt; [build-options]
</pre><p>Naturally you have to specify a fully qualified path to the build script for this to work. Alternatively, you can add the path to the Urho3D project root to the PATH environment variable in order to make the build scripts available everywhere.</p>
<p>Our CMakeLists.txt files are designed to work with most of the generators supported by CMake: Makefile, Xcode, VS, and even Ninja. Which build script to use is determined by which CMake generator (and toolchain) you intend to use in your build tree. For native build, you can just use cmake_generic.sh or cmake_generic.bat to let CMake to detect and decide which generator to use automatically. CMake should default to use "Unix Makefiles" generator on Linux and Mac host systems and it should default to use 32-bit "Visual Studio" generator on Windows host system when it is installed.</p>
<h2><a class="anchor" id="Build_Options"></a>
Build options</h2>
<p>A number of build options can be defined when invoking the build scripts or when configurating the project interactively using cmake-gui. To use one of these build options on the command line interface, pass it in this format "-DOPTION=VALUE" without the quotes. Most of the build options are boolean variables where setting their values to 0 means disabling a feature or setting an option to false, while 1 means enabling a feature or setting an option to true. The table below shows all the available build options and their default values. Non-boolean build options generally do not have any default values and are marked with '-' in the table. However, a few build options marked with '*' have their default values set differently based on the value of other variables or external factors. </p>
<table class="doxtable">
<tr>
<th>Build Option </th><th>Value</th><th>Description </th></tr>
<tr>
<td>ANDROID </td><td>0</td><td>Configure project using Android cross-compiler toolchain (cmake_generic.bat and cmake_generic.sh only) </td></tr>
<tr>
<td>RPI </td><td>0</td><td>Configure project using Raspberry Pi cross-compiler toolchain (cmake_generic.sh only) </td></tr>
<tr>
<td>WIN32 </td><td>0</td><td>Configure project using MinGW cross-compiler toolchain (cmake_generic.sh only); also applicable when cross-compiling 64-bit Windows platform </td></tr>
<tr>
<td>IOS </td><td>0</td><td>Configure project for targeting iOS platform (cmake_generic.sh and cmake-gui only) </td></tr>
<tr>
<td>URHO3D_64BIT </td><td>*</td><td>Enable 64-bit build, on MSVC default to 0, on other compilers the default is set based on the 64-bit capability of the chosen toolchain on host system </td></tr>
<tr>
<td>URHO3D_ANGELSCRIPT </td><td>1</td><td>Enable AngelScript scripting support </td></tr>
<tr>
<td>URHO3D_LUA </td><td>0</td><td>Enable Lua scripting support </td></tr>
<tr>
<td>URHO3D_LUAJIT </td><td>0</td><td>Enable Lua scripting support using LuaJIT (check LuaJIT's CMakeLists.txt for more options) </td></tr>
<tr>
<td>URHO3D_LUAJIT_AMALG </td><td>0</td><td>Enable LuaJIT amalgamated build (LuaJIT only) </td></tr>
<tr>
<td>URHO3D_SAFE_LUA </td><td>0</td><td>Enable Lua C++ wrapper safety checks (Lua/LuaJIT only) </td></tr>
<tr>
<td>URHO3D_NETWORK </td><td>1</td><td>Enable Networking support </td></tr>
<tr>
<td>URHO3D_PHYSICS </td><td>1</td><td>Enable Physics support </td></tr>
<tr>
<td>URHO3D_NAVIGATION </td><td>1</td><td>Enable Navigation support </td></tr>
<tr>
<td>URHO3D_URHO2D </td><td>1</td><td>Enable 2D rendering &amp; physics support </td></tr>
<tr>
<td>URHO3D_SAMPLES </td><td>0</td><td>Build sample applications </td></tr>
<tr>
<td>URHO3D_TOOLS </td><td>1</td><td>Build tools (native and RPI only) </td></tr>
<tr>
<td>URHO3D_EXTRAS </td><td>0</td><td>Build extras (native and RPI only) </td></tr>
<tr>
<td>URHO3D_DOCS </td><td>0</td><td>Generate documentation as part of normal build (the 'doc' builtin target can be used to generate documentation regardless of this option's value) </td></tr>
<tr>
<td>URHO3D_DOCS_QUIET </td><td>0</td><td>Generate documentation as part of normal build, suppress generation process from sending anything to stdout </td></tr>
<tr>
<td>URHO3D_SSE </td><td>1</td><td>Enable SSE instruction set </td></tr>
<tr>
<td>URHO3D_MINIDUMPS </td><td>1</td><td>Enable minidumps on crash (VS only) </td></tr>
<tr>
<td>URHO3D_FILEWATCHER </td><td>1</td><td>Enable filewatcher support </td></tr>
<tr>
<td>URHO3D_PACKAGING </td><td>*</td><td>Enable resources packaging support, on Emscripten default to 1, on other platforms default to 0 </td></tr>
<tr>
<td>URHO3D_PROFILING </td><td>1</td><td>Enable profiling support </td></tr>
<tr>
<td>URHO3D_LOGGING </td><td>1</td><td>Enable logging support </td></tr>
<tr>
<td>URHO3D_TESTING </td><td>0</td><td>Enable testing support </td></tr>
<tr>
<td>URHO3D_TEST_TIMEOUT </td><td>*</td><td>Number of seconds to test run the executables (when testing support is enabled only), default to 10 on Emscripten platform and 5 on other platforms </td></tr>
<tr>
<td>URHO3D_OPENGL </td><td>0</td><td>Use OpenGL instead of Direct3D (Windows platform only) </td></tr>
<tr>
<td>URHO3D_D3D11 </td><td>0</td><td>Use Direct3D11 instead of Direct3D9 (Windows platform only); overrides URHO3D_OPENGL option </td></tr>
<tr>
<td>URHO3D_STATIC_RUNTIME</td><td>0</td><td>Use static C/C++ runtime libraries and eliminate the need for runtime DLLs installation (VS only) </td></tr>
<tr>
<td>URHO3D_WIN32_CONSOLE </td><td>0</td><td>Use console main() as entry point when setting up Windows executable targets (Windows platform only) </td></tr>
<tr>
<td>URHO3D_MACOSX_BUNDLE </td><td>0</td><td>Use MACOSX_BUNDLE when setting up Mac OS X executable targets (Xcode native build only) </td></tr>
<tr>
<td>URHO3D_LIB_TYPE </td><td>STATIC</td><td>Specify Urho3D library type, possible values are STATIC (default) and SHARED </td></tr>
<tr>
<td>URHO3D_SCP_TO_TARGET </td><td>-</td><td>Use scp to transfer executables to target system (non-Android cross-compiling build only), SSH digital key must be setup first for this to work, typical value has a pattern of usr:remote-loc </td></tr>
<tr>
<td>URHO3D_USE_LIB64_RPM </td><td>0</td><td>Enable 64-bit RPM CPack generator using /usr/lib64 and disable all other generators (Debian-based host only, which uses /usr/lib by default) </td></tr>
<tr>
<td>URHO3D_USE_LIB_DEB </td><td>0</td><td>Enable 64-bit DEB CPack generator using /usr/lib and disable all other generators (Redhat-based host only, which uses /usr/lib64 by default) </td></tr>
<tr>
<td>URHO3D_HOME </td><td>-</td><td>Path to Urho3D build tree or SDK installation location (external project only) </td></tr>
<tr>
<td>CMAKE_BUILD_TYPE </td><td>Release</td><td>Specify CMake build configuration (single-configuration generator only), possible values are Release (default), RelWithDebInfo, and Debug </td></tr>
<tr>
<td>CMAKE_INSTALL_PREFIX </td><td>*</td><td>Install path prefix, prepended onto install directories; default to 'c:/Program Files/Urho3D' on Windows host and '/usr/local' on all other non-Windows hosts </td></tr>
<tr>
<td>CMAKE_OSX_DEPLOYMENT_TARGET</td><td>-</td><td>Specify Mac OS X deployment target (OSX build only); default to current running OS X if not specified, the minimum supported target is 10.5 due to constraint from SDL library </td></tr>
<tr>
<td>IPHONEOS_DEPLOYMENT_TARGET</td><td>-</td><td>Specify iPhone OS deployment target (iOS build only); default to latest installed iOS SDK if not specified, the minimum spported target is 3.0 due to constraint from SDL library </td></tr>
<tr>
<td>ANDROID_ABI </td><td>armeabi-v7a</td><td>Specify target ABI (Android build only), possible values are arm64-v8a, armeabi, armeabi-v6 with VFP, armeabi-v7a (default), armeabi-v7a with NEON, armeabi-v7a with VFPV3, mips, mips64, x86, and x86_64 </td></tr>
<tr>
<td>ANDROID_NATIVE_API_LEVEL</td><td>*</td><td>Specify target API level (Android build only), possible values depends on installed NDK version, default to API level 12 on 32-bit ABIs, default to API level 21 on 64-bit ABIs </td></tr>
<tr>
<td>ANDROID_NDK_GDB </td><td>0</td><td>Enable ndk-gdb support (Android Debug build only) </td></tr>
<tr>
<td>MINGW_PREFIX </td><td>-</td><td>Prefix path to MinGW cross-compiler tools (MinGW cross-compiling build only) </td></tr>
<tr>
<td>MINGW_SYSROOT </td><td>-</td><td>Path to MinGW system root (MinGW cross-compiling build only) </td></tr>
<tr>
<td>RPI_PREFIX </td><td>-</td><td>Prefix path to Raspberry Pi cross-compiler tools (RPI cross-compiling build only) </td></tr>
<tr>
<td>RPI_SYSROOT </td><td>-</td><td>Path to Raspberry Pi system root (RPI cross-compiling build only) </td></tr>
<tr>
<td>RPI_ABI </td><td>*</td><td>Specify target ABI (RPI build only), possible values are armeabi-v6 (default for RPI 1), armeabi-v7a (default for RPI 2), armeabi-v7a with NEON, and armeabi-v7a with VFPV4 </td></tr>
<tr>
<td>EMSCRIPTEN_ROOT_PATH </td><td>-</td><td>Root path to Emscripten cross-compiler tools (Emscripten cross-compiling build only) </td></tr>
<tr>
<td>EMSCRIPTEN_SYSROOT </td><td>-</td><td>Path to Emscripten system root (Emscripten cross-compiling build only) </td></tr>
<tr>
<td>EMSCRIPTEN_ALLOW_MEMORY_GROWTH</td><td>0</td><td>Enable memory growing based on application demand (Emscripten cross-compiling build only) </td></tr>
<tr>
<td>EMSCRIPTEN_TOTAL_MEMORY</td><td>*</td><td>Specify the total size of memory to be used (Emscripten cross-compiling build only); default to 33554432 (32MB), this option is ignored when EMSCRIPTEN_ALLOW_MEMORY_GROWTH=1 </td></tr>
<tr>
<td>EMSCRIPTEN_SHARE_DATA</td><td>0</td><td>Enable sharing data file support (Emscripten cross-compiling build only) </td></tr>
<tr>
<td>EMSCRIPTEN_EMRUN_BROWSER</td><td>firefox</td><td>Specify the particular browser to be spawned by emrun during testing (Emscripten cross-compiling build only), use 'emrun &ndash;list_browsers' command to get the list of possible values </td></tr>
</table>
<p>Note that the specified build option values are cached by CMake after the initial configuration step. The cached values will be used by CMake in the subsequent configuration. The same build options are not required to be specified again and again. But once a non-default build option value is being cached, it can only be reverted back to its default value by explicitly resetting it. That is, simply by not passing the corresponding build option would not revert it back to its default. One way to revert all the build options to their default values is by clearing the CMake cache by executing cmake_clean.bat or cmake_clean.sh with the location of the build tree as the first argument or by executing it in the build tree itself.</p>
<h2><a class="anchor" id="Building_Native"></a>
Native build process</h2>
<p>Urho3D uses CMake (<a href="http://www.cmake.org">http://www.cmake.org</a>) to build. The process has two steps:</p>
<ol type="1">
<li>Run CMake in the root directory (which is also CMake's source tree) with your preferred generator and toolchain specified to generate the build tree. You can use cmake-gui or the provided batch files or shell scripts on the respective host system. All the batch files and shell scripts expect the build tree location to be passed as the first argument, or to execute them in the build tree itself when reconfiguring the existing build tree.<br/>
<ul>
<li>Windows: cmake_vs20xx.bat, cmake_mingw.bat, cmake_codeblock.bat, cmake_ninja.bat, or cmake_generic.bat<br/>
</li>
<li>Mac OS X: cmake_macosx.sh, cmake_codeblocks.sh, cmake_ninja.sh, or cmake_generic.sh<br/>
</li>
<li>Linux: cmake_eclipse.sh, cmake_codeblocks.sh, cmake_ninja.sh, or cmake_generic.sh<br/>
</li>
<li>Raspberry Pi: cmake_rpi.sh, cmake_eclipse.sh, cmake_codeblocks.sh, cmake_ninja.sh, or cmake_generic.sh<br/>
</li>
</ul>
</li>
<li>Use the IDE of your choice to open the CMake's generated project file or solution file in the build tree. Change the build configuration (Debug/Release) and change the built-in target to ALL_BUILD to build all the targets.<br/>
<ul>
<li>Visual Studio: open Urho3D.sln<br/>
</li>
<li>Xcode: open Urho3D.xcodeproj<br/>
</li>
<li>CodeBlocks: open Urho3D.cbp<br/>
</li>
<li>Eclipse: import project using File|Import "Existing Projects into Workspace"<br/>
</li>
</ul>
</li>
</ol>
<p>Note that Eclipse requires CDT plugin to build C/C++ project. When using generator backed by Unix Makefiles, you can also execute make command directly in the build tree to build the project.</p>
<p>On Windows platform Urho3D can use either Direct3D 9 (default), Direct3D 11 or OpenGL rendering. Other platforms always use OpenGL. Use the CMake options "-DURHO3D_D3D11=1" or "-DURHO3D_OPENGL=1" to choose the non-default APIs.</p>
<p>If using MinGW to compile, DirectX headers may need to be acquired separately. They can be copied to the MinGW installation eg. from the following package: <a href="http://www.libsdl.org/extras/win32/common/directx-devel.tar.gz">http://www.libsdl.org/extras/win32/common/directx-devel.tar.gz</a> These will be missing some of the headers related to shader compilation, so a MinGW build will use OpenGL by default. To build in Direct3D mode, the MinGW-w64 port is necessary: <a href="http://mingw-w64.sourceforge.net/">http://mingw-w64.sourceforge.net/</a>. Using it, Direct3D can be enabled with the "-DURHO3D_OPENGL=0" build option.</p>
<p>After the build is complete, the programs can be run from the bin subdirectory in the build tree. These include the Urho3D player application, which can run application scripts, the tools, and C++ sample applications if they have been enabled. Unless your build tree location is also the same as the Urho3D project source tree, in order to run the Urho3D executables successfully, you must do one of the following first:</p>
<ul>
<li>Copy both the bin/Data and bin/CoreData directories in the source tree to the bin subdirectory in the build tree.</li>
<li>Instead of copying, just create symbolic links in the build tree pointing to the above two directories.</li>
<li>Or even better, use the 'resource prefix path' <a class="el" href="_running.html#Running_Commandline">engine parameter</a> by setting URHO3D_PREFIX_PATH variable in your host environment. The prefix variable must be set to an absolute path which contains the resource directories.</li>
<li>Or use the URHO3D_PACKAGING build option which would package the resource directories as *.pak files in the bin subdirectory in the build tree.</li>
</ul>
<p>The Mac OS X executables can be built with all the resources bundled into a single app directory. In order to enable this, set the URHO3D_MACOSX_BUNDLE build option when configuring the build tree for the Mac OS X platform. The bundled app can be launched just by double-clicking from the Finder without worrying about setting the 'resource prefix path'. This is because the URHO3D_PREFIX_PATH environment variable has been set internally to point to the resources directory that is already bundled in the app. Note, however, if you do not launch the app via the Apple "Launch Services" (such as when you are debugging or by calling the executable directly inside the bundled app directory via CLI) then you still need to set the 'resource prefix path' manually as described in the previous paragraph.</p>
<p>The Windows executables are by default built as Windows application instead of console application. You can set the URHO3D_WIN32_CONSOLE build option to override this. As console application, the standard output and standard error streams of the executable are redirected to console.</p>
<p>To run the Urho3D player application from the Visual Studio debugger, set the Urho3DPlayer project as the startup project and enter its relative path and filename into Properties -&gt; Debugging -&gt; Command: ../../../bin/Urho3DPlayer.exe. Additionally, entering -w into Debugging -&gt; Command Arguments is highly recommended. This enables startup in windowed mode: without it running into an exception or breakpoint will be obnoxious as the mouse cursor will likely be hidden. To actually make the Urho3DPlayer application do something useful, it must be supplied with the name of the script file it should load and run. You can try for example the following arguments:</p>
<pre class="fragment">Scripts/NinjaSnowWar.as -w
</pre><p>To run from Eclipse on Linux, locate and select the Urho3DPlayer executable in the Project Explorer. From the menu, choose "Run Configurations" to create a new launch configuration for "C/C++ Application". Switch to "Arguments" tab, specify the argument required by Urho3DPlayer executable.</p>
<p>To run from Xcode on Mac OS X, edit the Product Scheme to set "Run" setting to execute "Urho3DPlayer" in the "Info" tab. In the "Arguments" tab, specify the arguments required by Urho3DPlayer executable. Ensure the check boxes are ticked on the argument entries that you want to be active.</p>
<h2><a class="anchor" id="Building_Android"></a>
Android build process</h2>
<p>First, if you are building under Windows host without MKLINK support then copy bin/Data and bin/CoreData directories to the Android/assets directory (you can use the provided batch file CopyData.bat). This step is not necessary for Windows host with MKLINK support and other non-Windows host systems.</p>
<p>Set the ANDROID_NDK environment variable to point to your Android NDK. On Windows, ensure that make.exe from the Android NDK is included in the path and is executable from the command line.</p>
<p>On Windows host, execute cmake_android.bat. On OS X or Linux host, execute cmake_android.sh. Then go to the build tree and execute the below commands to start the build.</p>
<pre class="fragment">- android update project -p . -t &lt;target-id&gt;
- make -j &lt;num_jobs&gt;
- ant debug
</pre><p>Where the &lt;target-id&gt; is one of the target id returned by "android list target" command. The &lt;num-jobs&gt; is the number of concurrent compiler jobs to be spawned by make command.</p>
<p>After the commands finish successfully, the APK should have been generated in the build tree's "bin" subdirectory, from where it can be installed on a device or an emulator. The command "ant installd" can be used for this. Optionally when you have Rake installed, after the debug APK has been installed then you can use "rake android" command to automate the test running of the APK on an attached Android (virtual) device.</p>
<p>For a release build, use the "ant release" command instead of "ant debug" and follow the Android SDK instructions on how to sign your APK properly.</p>
<p>By default the Android package for Urho3D is com.googlecode.urho3d. For a real application you must replace this with your own package name. The Urho3D activity subclasses the SDLActivity from org.libsdl.app package, whose name (or the JNI code from SDL library) does not have to be changed.</p>
<p>Note that the native code is built by default for armeabi-v7a ABI. To make your program compatible also with old Android devices, build also an armeabi version by reconfiguring the build tree again with the build option "-DANDROID_ABI=armeabi" added, then execute make again in the build directory. Similarly, the native code can be built using 64-bit ABI by changing the value of this build option. See <a class="el" href="_building.html#Build_Options">Build options</a> for all the possible values. Note that CMake doesn't allow changing of its compiler settings in an existing build tree, so before reconfiguring to use an incompatible ANDROID_ABI most likely you need to clean the CMake cache first.</p>
<p>You can also build and deploy using Eclipse IDE with ADT plugin. To do that, execute cmake_eclipse.sh with "-DANDROID=1" build option set. Import "Existing Android Code into Workspace" from the CMake generated Eclipse project file in the build tree. Switch Eclipse IDE to use Java Perspective. Update project properties to choose the desired Android API target. Choose "Run" to let ADT automatically build and deploy the application to Android (virtual) device.</p>
<h2><a class="anchor" id="Building_Ios"></a>
iOS build process</h2>
<p>Run cmake_ios.sh. This generates an Xcode project named Urho3D.xcodeproj.</p>
<p>Open the Xcode project and check the properties for the Urho3D project (topmost in the Project Navigator.) In Architectures -&gt; Base SDK, choose your iOS SDK (CMake would automatically select latest iOS when generating the Xcode project). In Code Signing, enter your developer identity as necessary. Also ensure you have changed the built-in target to ALL_BUILD to build all the targets.</p>
<p>The Urho3DPlayer target will actually build the application bundle and copy resources from bin/Data and bin/CoreData directories. Edit its build scheme to choose debug or release mode.</p>
<p>To run from Xcode on iPhone/iPad Simulator, edit the Product Scheme to set "Run" destination setting to "iPhone Simulator" or "iPad Simulator", and executable to "Urho3DPlayer.app".</p>
<h2><a class="anchor" id="Building_RaspberryPi"></a>
Raspberry Pi build process</h2>
<p>For native build on Raspberry Pi itself, use the similar process for <a class="el" href="_building.html#Building_Native">Native build process</a> described above.</p>
<p>For cross-compiling build on an Linux host system, firstly set the RPI_PREFIX environment variable or build option to point to your Raspberry Pi Cross-Compiling tool are located. You can setup the tool using <a href="http://crosstool-ng.org/">crosstool-NG</a> or just download one from <a href="https://github.com/raspberrypi/tools">https://github.com/raspberrypi/tools</a>. Secondly, set the RPI_SYSROOT environment variable or build option to point to your Raspbian or Pidora system root. You must install the Urho3D prerequisites software development packages for Raspberry Pi (see <a class="el" href="_building.html#Building_Prerequisites">Building prerequisites</a>) in the system root before attempting to do the Urho3D cross-compiling build. You are recommended to download the Raspbian system root with Urho3D prerequisite software installed from <a href="https://github.com/urho3d/rpi-sysroot">https://github.com/urho3d/rpi-sysroot</a>. You can just download from the "strip" branch to cut down the download time and size. Alternatively, if you have a fast LAN connection then you can also opt to mount the system root on your actual Raspberry Pi device to your host system via SSHFS and set the RPI_SYSROOT to use the mount point.</p>
<p>Execute cmake_raspi.sh then go to the build tree to execute make command. You may pass the optional RPI_ABI build option to specifically target for the Raspberry Pi 2. After the build is complete, the ARM executables can be found in the build tree's "bin" subdirectory.</p>
<p>You can also build, deploy, run/debug (as C/C++ Remote Application) using Eclipse IDE. To do that, execute cmake_eclipse.sh with "-DRPI=1" build option set. Import the CMake generated Eclipse project in the build tree into Eclipse's workspace. Build the project as usual. Optionally, use the "URHO3D_SCP_TO_TARGET" build option to automatically deploy the ARM executables to target Raspberry Pi device as part of build process; or configure Eclipse to perform a "download to target path" in the Run/Debug configuration for C/C++ Remote Application. Either way, you have to configure the Run/Debug configuration to let it know how to reach your target Raspberry Pi device.</p>
<h2><a class="anchor" id="Building_MinGW"></a>
MinGW cross-compile build process</h2>
<p>It is possible to cross-compile Urho3D for Windows using a Linux host system. The process is largely the same as the <a class="el" href="_building.html#Building_Native">Linux native build</a> process described above.</p>
<p>To cross-compile, the MinGW toolchain (compiler, linker and w32api) needs to be installed on the system. You will also need the DirectX header files, those can be downloaded and installed from the following packet: <a href="http://www.libsdl.org/extras/win32/common/directx-devel.tar.gz">http://www.libsdl.org/extras/win32/common/directx-devel.tar.gz</a>.</p>
<p>For activating the MinGW toolchain, and to allow it to find the correct compiler, the MINGW_PREFIX environment variable needs to be set. This variable should be set to the prefix of the compiler name, e.g. /usr/bin/x86_64-w64-mingw32 where it would be used to find /usr/bin/x86_64-w64-mingw32-gcc and /usr/bin/x86_64-w64-mingw32-g++, etc. Optionally you can also set MINGW_SYSROOT environment variable or build option to point to your MinGW system root, if it is not installed in a normal expected location.</p>
<p>Execute cmake_mingw.sh then go to the build tree to execute make command. After the build is complete, the Windows executables can be found in the build tree's "bin" subdirectory.</p>
<h2><a class="anchor" id="Building_Emscripten"></a>
Emscripten build process (EXPERIMENTAL)</h2>
<blockquote class="doxtable">
<p>WHAT DOESN'T WORK:</p>
<ul>
<li>Networking. Javascript can only use http and websockets protocols so it's not likely that kNet will ever function.</li>
<li>AngelScript scripting support.</li>
</ul>
<p></p>
</blockquote>
<p>This section assumes you have already updated, installed, and activated the latest Emscripten (trans-)compiler toolchain on your host system as per described in <a href="http://kripken.github.io/emscripten-site/docs/getting_started/downloads.html">http://kripken.github.io/emscripten-site/docs/getting_started/downloads.html</a>.</p>
<p>Set the EMSCRIPTEN_ROOT_PATH environment variable or build option to point to the root path of Emscripten cross-compiler tools. The Emscripten sysroot path will be derived from the root path, usually from 'system' subdir relative to the root path. However, you can optionally set the EMSCRIPTEN_SYSROOT environment variable or build option to point to another system root path.</p>
<p>On Windows host, execute cmake_emscripten.bat. On OS X or Linux host, execute cmake_emscripten.sh. Then go to the build tree and execute the 'make' command to start the build as usual. You may want to set the URHO3D_SAMPLES build option to build all the samples. You may also optionally set the URHO3D_LUA build option to enable Lua scripting support. If you encounter "Too many open files" warning when archiving the Urho3D static library, follow by "Unresolved symbol" errors on OS X then you have to increase the soft-limit in your host system before rebuilding the library and all the main targets.</p>
<p>For example, to double the limit (which normally defaults to 256 on OS X): </p>
<pre class="fragment">ulimit -Sn 512
</pre><p>After the commands finish successfully, the HTMLs and its correspondng data files should have been generated in the build tree's "bin" subdirectory, from where it can be launched in a browser.</p>
<p>On Windows building with Emscripten requires a MinGW toolchain. The one that can be installed through emsdk may not work correctly, but for example <a href="http://sourceforge.net/projects/mingw-w64/">http://sourceforge.net/projects/mingw-w64/</a> with the default install settings has been known to work.</p>
<p>If CMake complains that emcc is not able to compile a test program, try reactivating your current Emscripten cross-compiler tools with 'emsdk activate &lt;your-tools-version&gt;', clear all generated *.cmake files as well as the CMake cache, and retry running CMake.</p>
<h2><a class="anchor" id="Building_64bit"></a>
Native 64bit build</h2>
<p>When using MSVC compiler, Urho3D common CMake module configures the build tree to target a 32-bit platform by default. When using other non-MSVC compilers (like GCC or Clang), the module sets the default to 32-bit or 64-bit based on the chosen toolchain in the build tree. You can, however, use the "URHO3D_64BIT" build option to override the default, i.e. by setting the option to '0' (for 32-bit) and '1' (for 64-bit) explicitly.</p>
<h2><a class="anchor" id="Building_Library"></a>
Library build</h2>
<p>The build process first builds the Urho3D library target (either static or shared). The library is then linked against by other targets like tools and samples that reference Urho3D as one of the external libraries. The Urho3D library type is defaulted to static, so the build process would generate standalone executables as previous releases. The Urho3D library type can be changed using "URHO3D_LIB_TYPE" build option.</p>
<p>To install the Urho3D library as an SDK, use the usual 'make install' command. There is an equivalent built-in target called "install" in Visual Studio solution and Xcode project to perform the SDK installation. This could be useful when you want your application to always link against a 'stable' installed version of the Urho3D library, while keeping your Urho3D project root tree in sync with origin/master; or when you want other users in the same host system to use the installed Urho3D SDK instead of them building from source again.</p>
<p>The default install prefix is 'c:/Program Files/Urho3D' on Windows host and '/usr/local' on all other non-Windows hosts. You can use the CMAKE_INSTALL_PREFIX build option to alter this prefix path. However, when cross-compiling you may actually want to alter the final installation destination by supplying DESDIR environment variable instead of altering the CMAKE_INSTALL_PREFIX variable directly, especially when using Urho3D library as shared library type because the installed executables have their RPATH adjusted relative to CMAKE_INSTALL_PREFIX. The DESTDIR environment variable is not applicable for installation on Windows host, i.e. it can only use CMAKE_INSTALL_PREFIX variable to alter the final installation destination. This is not a lost, however, because there is no RPATH adjustment for Windows platform, but as the result the Urho3D.dll will be installed in a same directory as the installed executables.</p>
<p>If the Urho3D SDK is installed to a system-wide default location then the Urho3D library can be found by FindUrho3D CMake module automatically without the help of URHO3D_HOME environment variable or build option. When cross-compiling, the system-wide default location is usually in the system root of the cross-compiling target. To get a corresponding system root path for a cross-compiling build tree, you can use SYSROOT internal variable stored in the CMake cache. You can then use the system root path to set the DESTDIR environment variable in order to stage the Urho3D SDK installation in the corresponding system root. For example:</p>
<pre class="fragment">cd /path/to/your/Urho3D/build-tree
DESTDIR=$(grep SYSROOT CMakeCache.txt |cut -d'=' -f2) make install
</pre><p>Note that SYSROOT variable is empty when the build tree is not setup for cross-compiling.</p>
<p>Refer to <a class="el" href="_using_library.html">Using Urho3D as external library</a> on how to setup your own project to use Urho3D as external library.</p>
<p>Urho3D should be built as a shared library if your application consists of multiple modules (main executable + other shared libraries) that all link to Urho3D. The reason for this is that Urho3D contains a few sensitive static data values, such as the main thread's ID, which will not work properly if they are duplicated due to multiple static linkage.</p>
<h2><a class="anchor" id="Building_Docs"></a>
Documentation build</h2>
<p>If "URHO3D_DOCS" build option is set then a normal build would not only build Urho3D binaries but also Urho3D documentation automatically. If the option is not set then the documentation can still be built by manually invoking 'make doc' command or using its equivalent built-in target in IDE.</p>
<p>The prerequisites are Doxygen and Graphviz. Tools to dump the <a class="el" href="_script_a_p_i.html">AngelScript API</a> for the default <a class="el" href="class_urho3_d_1_1_script.html">scripting</a> subsystem and the <a class="el" href="_lua_script_a_p_i.html">LuaScript API</a> (when the <a class="el" href="class_urho3_d_1_1_lua_script.html" title="Lua script subsystem.">LuaScript</a> subsystem is also enabled) are being built at the same time when all the native tools are built.</p>
<h2><a class="anchor" id="Building_Shaders"></a>
Compiling Direct3D shaders</h2>
<p>When building for Direct3D9 with the Windows 8 SDK (Visual Studio 2012+), copy d3dcompiler_46.dll from "C:\Program Files (x86)\Windows Kits\8.0\bin\x86" to build tree's "bin" directory so that Urho3D executables will run correctly. When building for Direct3D11, copy d3dcompiler_47.dll from "C:\Program Files (x86)\Windows Kits\8.1\bin\x86" to the "bin" directory. In both cases, if compiling Urho3D as 64-bit, copy from the "bin\x64" directory instead.</p>
<p>OpenGL does not depend on a separate shader compiler DLL.</p>
<h2><a class="anchor" id="Using_ccache"></a>
Using ccache</h2>
<p>ccache is a compiler cache software available on Linux and Mac OS X host systems. It speeds up the build by bypassing the actual compilation and reusing the result from previous compilation when the cache is hit. As such, this is optional in the build process. In order to enable ccache support and make it work correctly when building/using Urho3D library with GCC/Clang precompiled header enabled, the following environment variables must be set: </p>
<pre class="fragment">USE_CCACHE=1
CCACHE_SLOPPINESS=pch_defines,time_macros
</pre><p>Failure to do so would cause the precompiled header cannot be used by ccache. When ccache is setup correctly and with more hits than misses then even clean build can be done as fast as incremental build. The ccache support is available for native compiler toolchains as well as all cross-compiler toolchains supported by Urho3D.</p>
<blockquote class="doxtable">
<p>There are some caveats with ccache support on Emscripten compiler toolchain. At the moment to enable ccache support for Emscripten, you also need to set 'CCACHE_CPP2' environment variable to 1 (see Emscripten issue <a href="https://github.com/kripken/emscripten/issues/3365">#3365</a> for more detail). This upstream issue has been closed. The issue is now fixed in the Emscripten incoming branch.</p>
<p></p>
</blockquote>
<p>You may also want to set 'CCACHE_COMPRESS' environment variable to 1 to enable the compression of the cached objects. It is a trade-off between cache size and build time.</p>
<p>Ensure the ccache symlinks directory is being added as the first entry in the 'PATH' environment variable so the symlinks of the compiler toolchain is being found first by CMake rather than the actual compiler toolchain. This is especially important for native build. Usually the 'PATH' environment variable has been set correctly for ccache in RedHat-based host system such as Fedora, but it is not the case in Debian-based host system such as Ubuntu nor in Mac OS X host system with homebrew's ccache installation. For the latter case, use "whereis -b ccache" or "brew info ccache" to find out where your ccache symlinks directory is and adjust the 'PATH' environment variable accordingly.</p>
<p>Note that these environment variables are used by ccache itself and not by our CMake build rules, so they must remain set in the host system not only while generating the initial project file using CMake but also while building the project later.</p>
<p>Xcode IDE and its CLI version, xcodebuild, do not work with ccache out of the box. They probably don't need it because internally they already cache the derived build data. However, if you are performing a lot of switching between different checked out versions of the project source tree or performing a lot of clean build similar to continuous integration build then probably it is more beneficial to hack Xcode/xcodebuild to use ccache. As it is a hack, do the following at your own risk.</p>
<p>On Xcode 5: </p>
<pre class="fragment">cd $(dirname $(xcodebuild -find-executable clang))
for compiler in clang clang++; do mv $compiler{,.orig} &amp;&amp; ln -sf $(which ccache) $compiler; done
</pre><p>On Xcode 6: </p>
<pre class="fragment">cd $(dirname $(xcodebuild -find-executable clang))
cp -p $(which ccache) .
for compiler in clang clang++; do mv $compiler{,.orig} &amp;&amp; sudo mv /usr/bin/$compiler{,.orig} &amp;&amp; sudo ln -sf $(pwd)/$compiler.orig /usr/bin/$compiler &amp;&amp; ln -sf ccache $compiler; done
</pre><p>Xcode 6 has done something funky internally. It won't build unless the symlink resolves to an executable within its own rooted-'/usr/bin' in Xcode.app package. The 'ccache' executable is physically copied to this location for this reason. But as the result, you have to manually keep this copy up to date when upgrading 'ccache'. </p>
</div></div><!-- contents -->
